// Copyright 2023 quocdang1998
#include "merlin/candy/optmz/adam.hpp"

#include <cstdio>

#include "merlin/candy/model.hpp"  // merlin::candy::Model

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Adam
// ---------------------------------------------------------------------------------------------------------------------

#ifdef __NVCC__

// Erase train history GPU
__cudevice__ void candy::optmz::Adam::erase_history_gpu(std::uint64_t thread_idx, std::uint64_t block_size) noexcept {
    std::uint64_t size = this->register_moments_.size();
    for (std::uint64_t i_param = thread_idx; i_param < size; i_param += block_size) {
        this->register_moments_[i_param] = 0.0;
    }
}

// Update model by gradient value of current thread
__cudevice__ void candy::optmz::Adam::update_gpu(candy::Model * p_model, floatvec * p_gradient, void * share_ptr,
                                                 std::uint64_t thread_idx, std::uint64_t block_size) noexcept {
    // get data from share memory
    double & learning_rate = *(reinterpret_cast<double *>(share_ptr));
    double & beta_m = *(&learning_rate + 1);
    double & beta_v = *(&beta_m + 1);
    double & bias = *(&beta_v + 1);
    double *& register_moments_data = *(reinterpret_cast<double **>(&bias + 1));
    std::uint64_t & time_step = *(reinterpret_cast<std::uint64_t *>(&register_moments_data + 1));
    // add 1 to time step
    if (thread_idx == 0) {
        time_step++;
    }
    __syncthreads();
    // loop over each parameter
    for (std::uint64_t i_param = thread_idx; i_param < p_gradient->size(); i_param += block_size) {
        // calculate first and second moment
        register_moments_data[2 * i_param] *= beta_m;
        register_moments_data[2 * i_param] += (1.0 - beta_m) * (*p_gradient)[i_param];
        register_moments_data[2 * i_param + 1] *= beta_v;
        register_moments_data[2 * i_param + 1] += (1.0 - beta_v) * (*p_gradient)[i_param] * (*p_gradient)[i_param];
        // update parameters
        double & param = (*p_model)[i_param];
        double corrected_first_moment = register_moments_data[2 * i_param];
        corrected_first_moment /= 1.0 - std::pow(beta_m, time_step);
        double corrected_second_moment = register_moments_data[2 * i_param + 1];
        corrected_second_moment /= 1.0 - std::pow(beta_v, time_step);
        double correction = learning_rate * corrected_first_moment;
        correction /= std::sqrt(corrected_second_moment) + bias;
        param -= correction;
    }
    __syncthreads();
}

// Copy data to a pre-allocated memory region by a GPU block of threads
__cudevice__ void * candy::optmz::Adam::copy_data_by_block(void * data_ptr, std::uint64_t thread_idx,
                                                           std::uint64_t block_size) {
    double * learning_rate_data = reinterpret_cast<double *>(data_ptr);
    double * beta_m_data = learning_rate_data + 1;
    double * beta_v_data = beta_m_data + 1;
    double * bias_data = beta_v_data + 1;
    double ** register_moments_data = reinterpret_cast<double **>(bias_data + 1);
    std::uint64_t * time_step_data = reinterpret_cast<std::uint64_t *>(register_moments_data + 1);
    if (thread_idx == 0) {
        *learning_rate_data = this->learning_rate_;
        *beta_m_data = this->beta_m_;
        *beta_v_data = this->beta_v_;
        *bias_data = this->bias_;
        *register_moments_data = this->register_moments_.data();
        *time_step_data = this->time_step_;
    }
    __syncthreads();
    return reinterpret_cast<void *>(time_step_data + 1);
}

// Copy data to a pre-allocated memory region by a single GPU threads
__cudevice__ void * candy::optmz::Adam::copy_data_by_thread(void * data_ptr) {
    double * learning_rate_data = reinterpret_cast<double *>(data_ptr);
    double * beta_m_data = learning_rate_data + 1;
    double * beta_v_data = beta_m_data + 1;
    double * bias_data = beta_v_data + 1;
    double ** register_moments_data = reinterpret_cast<double **>(bias_data + 1);
    std::uint64_t * time_step_data = reinterpret_cast<std::uint64_t *>(register_moments_data + 1);
    *learning_rate_data = this->learning_rate_;
    *beta_m_data = this->beta_m_;
    *beta_v_data = this->beta_v_;
    *bias_data = this->bias_;
    *register_moments_data = this->register_moments_.data();
    *time_step_data = this->time_step_;
    return reinterpret_cast<void *>(time_step_data + 1);
}

#endif  // __NVCC__

}  // namespace merlin
