// Copyright 2022 quocdang1998
#include "merlin/intpl/cartesian_grid.hpp"

#include "merlin/utils.hpp"  // merlin::contiguous_to_ndim_idx

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// CartesianGrid
// ---------------------------------------------------------------------------------------------------------------------

// Get shape of the grid
__cuhostdev__ intvec intpl::CartesianGrid::get_grid_shape(std::uint64_t * data_ptr) const noexcept {
    intvec result;
    if (data_ptr != nullptr) {
        result.assign(data_ptr, this->ndim());
    } else {
        result = intvec(this->ndim());
    }
    for (std::uint64_t i = 0; i < this->ndim(); i++) {
        result[i] = this->grid_vectors_[i].size();
    }
    return result;
}

// Get total number of points
__cuhostdev__ std::uint64_t intpl::CartesianGrid::size(void) const {
    std::uint64_t result = 1;
    for (std::uint64_t i = 0; i < this->grid_vectors_.size(); i++) {
        result *= this->grid_vectors_[i].size();
    }
    return result;
}

// Get element at a C-contiguous index
__cuhostdev__ floatvec intpl::CartesianGrid::operator[](std::uint64_t index) const noexcept {
    intvec nd_index = contiguous_to_ndim_idx(index, this->get_grid_shape());
    floatvec result(this->ndim(), 0);
    for (std::uint64_t i = 0; i < result.size(); i++) {
        result[i] = this->grid_vectors_[i][nd_index[i]];
    }
    return result;
}

// Get element at a multi-dimensional index
__cuhostdev__ floatvec intpl::CartesianGrid::operator[](const intvec & index) const noexcept {
    floatvec result(this->ndim(), 0);
    for (std::uint64_t i = 0; i < result.size(); i++) {
        result[i] = this->grid_vectors_[i][index[i]];
    }
    return result;
}

#ifdef __NVCC__

// Copy to shared memory
__cudevice__ void * intpl::CartesianGrid::copy_by_block(intpl::CartesianGrid * dest_ptr, void * grid_vector_data_ptr,
                                                        std::uint64_t thread_idx, std::uint64_t block_size) const {
    // shallow copy of grid vector
    floatvec * grid_vector_data = reinterpret_cast<floatvec *>(grid_vector_data_ptr);
    if (thread_idx == 0) {
        dest_ptr->grid_vectors_.data() = grid_vector_data;
        dest_ptr->grid_vectors_.size() = this->ndim();
    }
    __syncthreads();
    // copy data of each grid vector
    void * data_ptr = reinterpret_cast<void *>(grid_vector_data + this->ndim());
    for (std::uint64_t i_dim = 0; i_dim < this->ndim(); i_dim++) {
        data_ptr = this->grid_vectors_[i_dim].copy_by_block(grid_vector_data + i_dim, data_ptr, thread_idx, block_size);
    }
    return data_ptr;
}

// Copy to shared memory
__cudevice__ void * intpl::CartesianGrid::copy_by_thread(intpl::CartesianGrid * dest_ptr,
                                                         void * grid_vector_data_ptr) const {
    // shallow copy of grid vector
    floatvec * grid_vector_data = reinterpret_cast<floatvec *>(grid_vector_data_ptr);
    dest_ptr->grid_vectors_.data() = grid_vector_data;
    dest_ptr->grid_vectors_.size() = this->ndim();
    // copy data of each grid vector
    void * data_ptr = reinterpret_cast<void *>(grid_vector_data + this->ndim());
    for (std::uint64_t i_dim = 0; i_dim < this->ndim(); i_dim++) {
        data_ptr = this->grid_vectors_[i_dim].copy_by_thread(grid_vector_data + i_dim, data_ptr);
    }
    return data_ptr;
}

#endif  // __NVCC__

}  // namespace merlin
