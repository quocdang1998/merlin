// Copyright 2022 quocdang1998
#include "merlin/intpl/newton.hpp"

#include "merlin/array/array.hpp"           // merlin::array::Array
#include "merlin/array/parcel.hpp"          // merlin::array::Parcel
#include "merlin/intpl/cartesian_grid.hpp"  // merlin::intpl::CartesianGrid
#include "merlin/utils.hpp"                 // merlin::decrement_index

namespace merlin {

// Evaluate Newton interpolation without recursive
__cuhostdev__ double intpl::eval_newton_single_core(const intpl::CartesianGrid & grid, const array::NdData & coeff,
                                                    const Vector<double> & x, std::uint64_t * iterator_data,
                                                    double * cummulative_register_data) {
// Type casting
#ifdef __CUDA_ARCH__
    const array::Parcel * p_coeff = static_cast<const array::Parcel *>(&coeff);
#else
    const array::Array * p_coeff = static_cast<const array::Array *>(&coeff);
#endif  // __CUDA_ARCH__
    // initialize storing vector
    std::uint64_t ndim = grid.ndim(), max_dim = ndim - 1;
    const intvec & shape = coeff.shape();
    intvec iterator;
    if (iterator_data == nullptr) {
        iterator = intvec(ndim, 0);
    } else {
        iterator.assign(iterator_data, ndim);
    }
    Vector<double> cum;
    if (cummulative_register_data == nullptr) {
        cum = Vector<double>(ndim, 0.f);
    } else {
        cum.assign(cummulative_register_data, ndim);
        for (std::uint64_t i_dim = 0; i_dim < ndim; i_dim++) {
            cum[i_dim] = 0.f;
        }
    }
    iterator[0] = coeff.shape()[0];
    decrement_index(iterator, shape);
    cum[max_dim] = (*p_coeff)[iterator];
    // loop over each point in coeff array
    while (!is_zeros(iterator)) {
        std::uint64_t i_dim = decrement_index(iterator, shape);
        if (i_dim == max_dim) {
            cum[i_dim] *= x[i_dim] - grid.grid_vectors()[i_dim][iterator[i_dim]];
            cum[i_dim] += (*p_coeff)[iterator];
        } else {
            cum[i_dim] *= x[i_dim] - grid.grid_vectors()[i_dim][iterator[i_dim] + 1];
            for (std::uint64_t i = i_dim + 1; i < max_dim; i++) {
                cum[i_dim] += (x[i] - grid.grid_vectors()[i][0]) * cum[i];
                cum[i] = 0;
            }
            cum[i_dim] += cum[max_dim];
            cum[max_dim] = (*p_coeff)[iterator];
        }
    }
    // finalize
    double result = 0.0;
    for (std::uint64_t i = 0; i < max_dim; i++) {
        result += (x[i] - grid.grid_vectors()[i][0]) * cum[i];
    }
    result += cum[max_dim];
    return result;
}

}  // namespace merlin
