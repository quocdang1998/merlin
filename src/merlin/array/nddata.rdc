// Copyright 2022 quocdang1998
#include "merlin/array/nddata.hpp"

#include "merlin/array/slice.hpp"  // merlin::array::Slice

namespace merlin {

// --------------------------------------------------------------------------------------------------------------------
// NdData
// --------------------------------------------------------------------------------------------------------------------

// Constructor from a slice
__cuhostdev__ array::NdData::NdData(const array::NdData & whole, const Vector<array::Slice> & slices) {
    // check size
    if (slices.size() != whole.ndim()) {
        CUHDERR(std::invalid_argument, "Dimension of Slices and NdData not compatible (expected %u, got %u).\n",
                static_cast<unsigned int>(whole.ndim()), static_cast<unsigned int>(slices.size()));
    }
    // create result
    std::uintptr_t data_ptr = reinterpret_cast<std::uintptr_t>(whole.data_);
    this->shape_ = intvec(whole.ndim());
    this->strides_ = intvec(whole.ndim());
    for (std::uint64_t i_dim = 0; i_dim < whole.ndim(); i_dim++) {
        auto [offset, shape, stride] = slices[i_dim].slice_on(whole.shape_[i_dim], whole.strides_[i_dim]);
        data_ptr += offset;
        this->shape_[i_dim] = shape;
        this->strides_[i_dim] = stride;
    }
    this->calc_array_size();
    this->data_ = reinterpret_cast<double *>(data_ptr);
    this->release_ = false;
}

// Calculate size of array
__cuhostdev__ void array::NdData::calc_array_size(void) noexcept {
    this->size_ = 1;
    for (std::uint64_t i = 0; i < this->ndim(); i++) {
        this->size_ *= this->shape_[i];
    }
}

}  // namespace merlin
