// Copyright 2022 quocdang1998
#include "merlin/array/array.hpp"

#include "merlin/logger.hpp"  // FAILURE, throw_linux_last_error, throw_windows_last_error

#if defined(__MERLIN_WINDOWS__)
#include <memoryapi.h>  // VirtualAlloc, VirtualFree, VirtualLock, VirtualUnlock
#include <windows.h>  // GetLastError
#elif defined(__MERLIN_LINUX__)
#include <sys/mman.h>  // mlock, posix_memalign
#include <unistd.h>  // sysconf
#endif

namespace merlin {

// --------------------------------------------------------------------------------------------------------------------
// Memory lock (allocated array always stays in the RAM)
// --------------------------------------------------------------------------------------------------------------------

// Allocate non pageable memory
float * allocate_memory(std::uint64_t size) {
    float * result = nullptr;
    #ifndef __MERLIN_CUDA__
        #if defined(__MERLIN_WINDOWS__)
        void * temp_ = ::VirtualAlloc(NULL, sizeof(float) * size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        result = reinterpret_cast<float *>(temp_);
        if (result == nullptr) {
            std::string err_message = throw_windows_last_error(::GetLastError());
            FAILURE(std::runtime_error, "Allocate memory failed with message \"%s\".\n", err_message.c_str());
        }
        bool success = ::VirtualLock(result, sizeof(float) * size);
        if (!success) {
            ::VirtualFree(result, sizeof(float)*size, 0);
            std::string err_message = throw_windows_last_error(::GetLastError());
            FAILURE(std::runtime_error, "Lock memory failed with message \"%s\".\n", err_message.c_str());
        }
        #elif defined(__MERLIN_LINUX__)
        size_t array_size = sizeof(float) * size;
        int failed = ::posix_memalign(reinterpret_cast<void **>(&result), ::sysconf(_SC_PAGESIZE), array_size);
        if (failed) {
            FAILURE(std::runtime_error, "Allocate memory failed.\n");
        }
        int err_ = ::mlock(result, sizeof(float) * size);
        if (err_ == -1) {
            ::free(result);
            std::string err_message = throw_linux_last_error();
            FAILURE(std::runtime_error, "Exclusive lock file failed with message \"%s\".\n", err_message.c_str());
        }
        #endif
    #else
    cudaError_t err_ = ::cudaMallocHost(&result, sizeof(float) * size);
    if (err_ != 0) {
        FAILURE(cuda_runtime_error, "Allocate non-pageable memory failed with message \"%s\".\n",
                ::cudaGetErrorName(err_));
    }
    #endif  // __MERLIN_CUDA__
    return result;
}

// Free non pageable memory
void free_memory(float * ptr, std::uint64_t size) {
    #ifndef __MERLIN_CUDA__
    #if defined(__MERLIN_WINDOWS__)
        bool success = ::VirtualUnlock(ptr, sizeof(float) * size);
        if (!success) {
            std::string err_message = throw_windows_last_error(::GetLastError());
            FAILURE(std::runtime_error, "Unlock memory failed with message \"%s\".\n", err_message.c_str());
        }
        ::VirtualFree(ptr, sizeof(float) * size, 0);
        #elif defined(__MERLIN_LINUX__)
        int err_ = ::munlock(ptr, sizeof(float) * size);
        if (err_ == -1) {
            std::string err_message = throw_linux_last_error();
            FAILURE(std::runtime_error, "Exclusive lock file failed with message \"%s\".\n", err_message.c_str());
        }
        ::free(ptr);
        #endif
    #else
    cudaError_t err_ = ::cudaFreeHost(ptr);
    if (err_ != 0) {
        FAILURE(cuda_runtime_error, "Free non-pageable memory failed with message \"%s\".\n",
                ::cudaGetErrorName(err_));
    }
    #endif  // __MERLIN_CUDA__
}

}  // namespace merlin
