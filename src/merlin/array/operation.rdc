// Copyright 2022 quocdang1998
#include "merlin/array/operation.hpp"

#include <cinttypes>  // PRIu64

#include "merlin/logger.hpp"  // CUHDERR

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// NdData tools
// ---------------------------------------------------------------------------------------------------------------------

// C-Contiguous strides from shape vector
__cuhostdev__ intvec array::contiguous_strides(const intvec & shape, std::uint64_t element_size) {
    intvec c_strides = intvec(shape.size(), element_size);
    for (std::int64_t i = c_strides.size() - 2; i >= 0; i--) {
        c_strides[i] = shape[i + 1] * c_strides[i + 1];
    }
    return c_strides;
}

// Calculate the number of bytes to jump to get element at a given C-contiguous index
__cuhostdev__ std::uint64_t array::get_leap(std::uint64_t index, const intvec & shape, const intvec & strides) noexcept {
    std::uint64_t cum_prod = 1, nd_index = 0, leap = 0;
    for (std::int64_t i_dim = shape.size() - 1; i_dim >= 0; i_dim--) {
        nd_index = (index / cum_prod) % shape[i_dim];
        leap += strides[i_dim] * nd_index;
        cum_prod *= shape[i_dim];
    }
    return leap;
}

// Longest contiguous segment and break index
__cuhostdev__ std::tuple<std::uint64_t, std::int64_t> array::lcseg_and_brindex(const intvec & shape,
                                                                               const intvec & strides) {
    // check size of 2 vectors
    if (shape.size() != strides.size()) {
        CUHDERR(std::runtime_error, "Size of shape (%" PRIu64 ") and size of strides (%" PRIu64 ") are not equal.\n",
                shape.size(), strides.size());
    }
    // initialize elements
    std::uint64_t ndim_ = shape.size();
    intvec contiguous_strides_ = array::contiguous_strides(shape, sizeof(double));
    std::uint64_t longest_contiguous_segment_ = sizeof(double);
    std::int64_t break_index_ = ndim_ - 1;
    // check if i-th element of strides equals to i-th element of contiguous_strides,
    // break at the element of different index
    for (std::int64_t i = ndim_ - 1; i >= 0; i--) {
        if (strides[i] == contiguous_strides_[i]) {
            longest_contiguous_segment_ *= shape[i];
            break_index_--;
        } else {
            break;
        }
    }
    return std::tuple<std::uint64_t, std::int64_t>(longest_contiguous_segment_, break_index_);
}

}  // namespace merlin
