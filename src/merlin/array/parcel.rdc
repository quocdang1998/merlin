// Copyright 2022 quocdang1998
#include "merlin/array/parcel.hpp"

#include "merlin/array/copy.hpp"  // merlin::array::contiguous_strides
#include "merlin/logger.hpp"  // CUDAERR
#include "merlin/utils.hpp"  // merlin::inner_prod, merlin::contiguous_to_ndim_idx

namespace merlin {

// --------------------------------------------------------------------------------------------------------------------
// Parcel
// --------------------------------------------------------------------------------------------------------------------

// Constructor from a slice
__cuhostdev__ array::Parcel::Parcel(const array::Parcel & whole, const Vector<array::Slice> & slices) :
array::NdData(whole, slices) {
    this->device_ = whole.device_;
    #ifndef __CUDA_ARCH__
    this->context_ = whole.context_;
    #endif  // __CUDA_ARCH__
}

#ifdef __NVCC__

// Get reference to an element at a given n-dim index
__cudevice__ double & array::Parcel::operator[](const intvec & index) {
    // calculate strides
    std::uint64_t strides = inner_prod(index, this->strides_);
    double * element_ptr = reinterpret_cast<double *>(reinterpret_cast<std::uintptr_t>(this->data_) + strides);
    return *element_ptr;
}

// Get reference to an element at a given C-contiguous index
__cudevice__ double & array::Parcel::operator[](std::uint64_t index) {
    // calculate index vector
    intvec index_ = contiguous_to_ndim_idx(index, this->shape_);
    return this->operator[](index_);
}

// Get const reference to an element at a given n-dim index
__cudevice__ const double & array::Parcel::operator[](const intvec & index) const {
    // calculate strides
    std::uint64_t strides = inner_prod(index, this->strides_);
    double * element_ptr = reinterpret_cast<double *>(reinterpret_cast<std::uintptr_t>(this->data_) + strides);
    return *element_ptr;
}

// Get constant reference to an element at a given C-contiguous index
__cudevice__ const double & array::Parcel::operator[](std::uint64_t index) const {
    // calculate index vector
    intvec index_ = contiguous_to_ndim_idx(index, this->shape_);
    return this->operator[](index_);
}

// Copy to shared memory
__cudevice__ void * array::Parcel::copy_to_shared_mem(array::Parcel * share_ptr, void * shape_strides_ptr) const {
    // copy meta data
    bool check_zeroth_thread = (threadIdx.x == 0) && (threadIdx.y == 0) && (threadIdx.z == 0);
    if (check_zeroth_thread) {
        share_ptr->data_ = this->data_;
        share_ptr->ndim_ = this->ndim_;
    }
    __syncthreads();
    // copy shape and strides
    void * strides_data_ptr = this->shape_.copy_to_shared_mem(&(share_ptr->shape_), shape_strides_ptr);
    void * result = this->strides_.copy_to_shared_mem(&(share_ptr->strides_), strides_data_ptr);
    return result;
}

// Copy to shared memory
__cudevice__ void * array::Parcel::copy_to_shared_mem_single(array::Parcel * share_ptr,
                                                             void * shape_strides_ptr) const {
    // copy meta data
    share_ptr->data_ = this->data_;
    share_ptr->ndim_ = this->ndim_;
    // copy shape and strides
    void * strides_data_ptr = this->shape_.copy_to_shared_mem_single(&(share_ptr->shape_), shape_strides_ptr);
    void * result = this->strides_.copy_to_shared_mem(&(share_ptr->strides_), strides_data_ptr);
    return result;
}

#endif  //  __NVCC__

}  // namespace merlin
