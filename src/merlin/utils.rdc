// Copyright 2022 quocdang1998
#include "merlin/utils.hpp"

#include <cinttypes>  // PRIu64
#include <cmath>      // std::floor, std::sqrt
#include <ctime>      // std::localtime, std::time, std::time_t, std::tm
#include <sstream>    // std::ostringstream

#include "merlin/logger.hpp"    // CUHDERR
#include "merlin/platform.hpp"  // __MERLIN_WINDOWS__, __MERLIN_LINUX__

#if defined(__MERLIN_WINDOWS__)
    #include <windows.h>  // ::GetCurrentProcessId
#elif defined(__MERLIN_LINUX__)
    #include <unistd.h>  // ::getpid
#endif

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// System
// ---------------------------------------------------------------------------------------------------------------------

// Get process ID in form of a string
std::string get_current_process_id(void) {
    std::ostringstream output;
#if defined(__MERLIN_WINDOWS__)
    output << ::GetCurrentProcessId();
#elif defined(__MERLIN_LINUX__)
    output << ::getpid();
#endif
    return output.str();
}

// Get date and time in form of a string
std::string get_time(void) {
    std::ostringstream output;
    std::time_t current_carlendar_time = std::time(nullptr);
    std::tm * now = std::localtime(&current_carlendar_time);
    output << (now->tm_year + 1900) << '-' << (now->tm_mon + 1) << '-' << now->tm_mday << '_' << now->tm_hour << ':'
           << now->tm_min << ':' << now->tm_sec;
    return output.str();
}

// ---------------------------------------------------------------------------------------------------------------------
// Multi-dimensional Index
// ---------------------------------------------------------------------------------------------------------------------

// Product of all elements of the vector
__cuhostdev__ std::uint64_t prod_elements(const intvec & v) {
    std::uint64_t result = 1;
    for (std::uint64_t i = 0; i < v.size(); i++) {
        result *= v[i];
    }
    return result;
}

// Inner product of 2 index vectors
__cuhostdev__ std::uint64_t inner_prod(const intvec & v1, const intvec & v2) {
    // check size of 2 vectors
    CASSERT(!is_same_size(v1, v2), CUHDERR, std::invalid_argument,
            "Size of v1 (%" PRIu64 ") and size of v2 (%" PRIu64 ") are not equal.\n", v1.size(), v2.size());
    // calculate inner product
    std::uint64_t inner_product = 0;
    for (std::uint64_t i = 0; i < v1.size(); i++) {
        inner_product += v1[i] * v2[i];
    }
    return inner_product;
}

// Convert n-dimensional index to C-contiguous index
__cuhostdev__ std::uint64_t ndim_to_contiguous_idx(const intvec & index, const intvec & shape) {
    // check size of 2 vectors
    CASSERT(!is_same_size(index, shape), CUHDERR, std::invalid_argument,
            "Size of index (%" PRIu64 ") and size of shape (%" PRIu64 ") are not equal.\n", index.size(), shape.size());
    // calculate contiguous index
    std::uint64_t c_index = 0, cum_prod = 1;
    for (std::int64_t i = index.size() - 1; i >= 0; i--) {
        c_index += index[i] * cum_prod;
        cum_prod *= shape[i];
    }
    return c_index;
}

// Convert C-contiguous index to n-dimensional index with allocating memory for result
__cuhostdev__ intvec contiguous_to_ndim_idx(std::uint64_t index, const intvec & shape) {
    // calculate index vector
    intvec nd_index(shape.size());
    std::uint64_t cum_prod = 1;
    for (std::int64_t i = shape.size() - 1; i >= 0; i--) {
        nd_index[i] = (index / cum_prod) % shape[i];
        cum_prod *= shape[i];
    }
    return nd_index;
}

// Convert C-contiguous index to n-dimensional index and save data to a pre-allocated memory
__cuhostdev__ void contiguous_to_ndim_idx(std::uint64_t index, const intvec & shape, std::uint64_t * data_ptr) {
    // calculate index vector
    std::uint64_t cum_prod = 1;
    for (std::int64_t i = shape.size() - 1; i >= 0; i--) {
        data_ptr[i] = (index / cum_prod) % shape[i];
        cum_prod *= shape[i];
    }
}

// Increment of n-dim index
__cuhostdev__ std::int64_t increment_index(intvec & index, const intvec & shape) {
    // check size of 2 vectors
    CASSERT(!is_same_size(index, shape), CUHDERR, std::invalid_argument,
            "Size of index (%" PRIu64 ") and size of shape (%" PRIu64 ") are not equal.\n", index.size(), shape.size());
    // increasing index
    std::int64_t i_dim = index.size();
    bool keep_decresing, not_dim_break;
    do {
        i_dim--;
        keep_decresing = (index[i_dim] == shape[i_dim] - 1);
        index[i_dim] = (keep_decresing) ? 0 : index[i_dim] + 1;
        not_dim_break = (i_dim != 0);
    } while (keep_decresing && not_dim_break);
    return (keep_decresing) ? i_dim-1 : i_dim;
}

// Increment of n-dim index
__cuhostdev__ std::int64_t decrement_index(intvec & index, const intvec & shape) {
    // check size of 2 vectors
    CASSERT(!is_same_size(index, shape), CUHDERR, std::invalid_argument,
            "Size of index (%" PRIu64 ") and size of shape (%" PRIu64 ") are not equal.\n", index.size(), shape.size());
    // decresing index
    std::int64_t i_dim = index.size();
    bool keep_decresing, not_dim_break;
    do {
        i_dim--;
        keep_decresing = (index[i_dim] == 0);
        index[i_dim] = (keep_decresing) ? shape[i_dim] - 1 : index[i_dim] - 1;
        not_dim_break = (i_dim != 0);
    } while (keep_decresing && not_dim_break);
    return (keep_decresing) ? i_dim-1 : i_dim;
}

// ---------------------------------------------------------------------------------------------------------------------
// List Division
// ---------------------------------------------------------------------------------------------------------------------

// Get a list of pointers divided from an original array
__cuhostdev__ Vector<double *> ptr_to_subsequence(double * original, const intvec & divider_length,
                                                  double ** data_ptr) {
    Vector<double *> result;
    if (data_ptr != nullptr) {
        result.assign(data_ptr, divider_length.size());
    } else {
        result = Vector<double *>(divider_length.size());
    }
    std::uint64_t jump = 0;
    for (std::uint64_t i = 0; i < divider_length.size(); i++) {
        result[i] = original + jump;
        jump += divider_length[i];
    }
    return result;
}

// Get index of sequence and index in that sequence of an index in original array
__cuhostdev__ std::array<std::uint64_t, 2> index_in_subsequence(std::uint64_t index_full_array,
                                                                const intvec & divider_length) noexcept {
    std::uint64_t i_list = 0;
    std::int64_t index_in_list = index_full_array;
    for (std::uint64_t i = 0; i < divider_length.size(); i++) {
        index_in_list -= divider_length[i];
        i_list += (index_in_list >= 0) ? 1 : 0;
        index_full_array = (index_in_list >= 0) ? index_in_list : index_full_array;
    }
    return {i_list, index_full_array};
}

// Get 2-dimensional triangular index from flatten index
__cuhostdev__ std::array<std::uint64_t, 2> triangular_index(std::uint64_t index) noexcept {
    std::array<std::uint64_t, 2> triangular_index;
    triangular_index[0] = std::floor((-1.f + std::sqrt(1.f + 8.f * index)) / 2.f);
    triangular_index[1] = index - (triangular_index[0] * (triangular_index[0] + 1)) / 2;
    return triangular_index;
}

// ---------------------------------------------------------------------------------------------------------------------
// Sparse Grid
// ---------------------------------------------------------------------------------------------------------------------

// Get size of a sub-grid given its level vector
__cuhostdev__ std::uint64_t calc_subgrid_size(const intvec & level_vector) noexcept {
    std::uint64_t subgrid_size = 1;
    for (std::uint64_t i_dim = 0; i_dim < level_vector.size(); i_dim++) {
        const std::uint64_t & dim_level = level_vector[i_dim];
        if (dim_level == 0) {
            continue;
        }
        subgrid_size *= ((dim_level == 1) ? 2 : (1 << (dim_level - 1)));
    }
    return subgrid_size;
}

// Get shape of Cartesian subgrid
__cuhostdev__ intvec get_level_shape(const intvec & level_vector) {
    intvec grid_shape(level_vector.size());
    for (std::uint64_t i = 0; i < level_vector.size(); i++) {
        if (level_vector[i] == 0) {
            grid_shape[i] = 1;
        } else if (level_vector[i] == 1) {
            grid_shape[i] = 2;
        } else {
            grid_shape[i] = 1 << (level_vector[i] - 1);
        }
    }
    return grid_shape;
}

}  // namespace merlin
