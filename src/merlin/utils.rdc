// Copyright 2022 quocdang1998
#include "merlin/utils.hpp"

#include <cinttypes>  // PRIu64
#include <ctime>  // std::localtime, std::time, std::time_t, std::tm
#include <sstream>  // std::ostringstream

#if defined(__MERLIN_WINDOWS__)
#include <windows.h>  // ::GetCurrentProcessId
#elif defined(__MERLIN_LINUX__)
#include <unistd.h>  // ::getpid
#endif

namespace merlin {

// --------------------------------------------------------------------------------------------------------------------
// System
// --------------------------------------------------------------------------------------------------------------------

// Get process ID in form of a string
std::string get_current_process_id(void) {
    std::ostringstream output;
    #if defined(__MERLIN_WINDOWS__)
    output << ::GetCurrentProcessId();
    #elif defined(__MERLIN_LINUX__)
    output << ::getpid();
    #endif
    return output.str();
}

// Get date and time in form of a string
std::string get_time(void) {
    std::ostringstream output;
    std::time_t current_carlendar_time = std::time(nullptr);
    std::tm * now = std::localtime(&current_carlendar_time);
    output << (now->tm_year + 1900) << '-' << (now->tm_mon + 1) << '-' <<  now->tm_mday << '_'
           << now->tm_hour << ':' << now->tm_min << ':' << now->tm_sec;
    return output.str();
}

// --------------------------------------------------------------------------------------------------------------------
// Multi-dimensional Index
// --------------------------------------------------------------------------------------------------------------------

// Product of all elements of the vector
__cuhostdev__ std::uint64_t prod_elements(const intvec & v) {
    std::uint64_t result = 1;
    for (std::uint64_t i = 0; i < v.size(); i++) {
        result *= v[i];
    }
    return result;
}

// Inner product of 2 index vectors
__cuhostdev__ std::uint64_t inner_prod(const intvec & v1, const intvec & v2) {
    // check size of 2 vectors
    if (!is_same_size(v1, v2)) {
        CUHDERR(std::invalid_argument, "Size of v1 (%" PRIu64 ") and size of v2 (%" PRIu64 ") are not equal.\n",
                v1.size(), v2.size());
    }
    // calculate inner product
    std::uint64_t inner_product = 0;
    for (std::uint64_t i = 0; i < v1.size(); i++) {
        inner_product += v1[i] * v2[i];
    }
    return inner_product;
}

// Convert n-dimensional index to C-contiguous index
__cuhostdev__ std::uint64_t ndim_to_contiguous_idx(const intvec & index, const intvec & shape) {
    // check size of 2 vectors
    if (!is_same_size(index, shape)) {
        CUHDERR(std::invalid_argument, "Size of index (%" PRIu64 ") and size of shape (%" PRIu64 ") are not equal.\n",
                index.size(), shape.size());
    }
    // calculate contiguous index
    std::uint64_t result = 0, cum_prod = 1;
    if (index.size() == 0) {
        CUHDERR(std::invalid_argument, "Size of index and shape vectors are 0.\n");
    }
    result += index[index.size()-1] * cum_prod;
    for (std::int64_t i = index.size()-2; i >= 0; i--) {
        cum_prod = cum_prod * shape[i+1];
        result += index[i]*cum_prod;
    }
    return result;
}

// Convert C-contiguous index to n-dimensional index
__cuhostdev__ intvec contiguous_to_ndim_idx(std::uint64_t index, const intvec & shape, std::uint64_t * data_ptr) {
    // calculate index vector
    intvec index_;
    if (data_ptr != nullptr) {
        index_.assign(data_ptr, shape.size());
    } else {
        index_ = intvec(shape.size());
    }
    if (shape.size() == 0) {
        return index_;  // empty shape vector
    }
    std::uint64_t cum_prod = 1;
    index_[shape.size()-1] = index % shape[shape.size()-1];
    for (std::int64_t i = shape.size()-2; i >= 0; i--) {
        cum_prod *= shape[i+1];
        index_[i] = (index / cum_prod) % shape[i];
    }
    return index_;
}

// Increment of n-dim index
__cuhostdev__ std::uint64_t increment_index(intvec & index, const intvec & shape) {
    // check size of 2 vectors
    if (!is_same_size(index, shape)) {
        CUHDERR(std::invalid_argument, "Size of index (%" PRIu64 ") and size of shape (%" PRIu64 ") are not equal.\n",
                index.size(), shape.size());
    }
    // trivial case: size zero -> do nothing
    std::uint64_t result = index.size();
    if (result == 0) {
        return result;
    }
    // increment of index
    result -= 1;
    index[result]++;
    while (index[result] >= shape[result]) {
        if (result == 0) {
            if (index[result] == shape[result]) {
                break;
            } else {
                CUHDERR(std::out_of_range, "Maximum size reached, cannot increase more.\n");
            }
        }
        index[result] = 0;
        index[--result] += 1;
    }
    return result;
}

// Increment of n-dim index
__cuhostdev__ std::uint64_t decrement_index(intvec & index, const intvec & shape) {
    // check size of 2 vectors
    if (!is_same_size(index, shape)) {
        CUHDERR(std::invalid_argument, "Size of index (%" PRIu64 ") and size of shape (%" PRIu64 ") are not equal.\n",
                index.size(), shape.size());
    }
    // trivial case: size zero -> do nothing
    std::uint64_t result = index.size();
    if (result == 0) {
        return result;
    }
    // decrement of index
    result -= 1;
    do {
        if (index[result] != 0) {
            index[result] -= 1;
            break;
        }
        index[result] = shape[result] - 1;
        if (result == 0) {
            for (std::uint64_t i = 0; i < index.size(); i++) {
                index[i] = 0;
            }
            CUHDERR(std::invalid_argument, "Minimum reached, cannot decrease more.\n");
            break;
        }
        result--;
    } while (true);
    return result;
}

// --------------------------------------------------------------------------------------------------------------------
// Sparse Grid
// --------------------------------------------------------------------------------------------------------------------

// Get size of a sub-grid given its level vector
__cuhostdev__ std::uint64_t calc_subgrid_size(const intvec & level_vector) noexcept {
    std::uint64_t subgrid_size = 1;
    for (std::uint64_t i_dim = 0; i_dim < level_vector.size(); i_dim++) {
        const std::uint64_t & dim_level = level_vector[i_dim];
        if (dim_level == 0) {
            continue;
        }
        subgrid_size *= ((dim_level == 1) ? 2 : (1 << (dim_level-1)));
    }
    return subgrid_size;
}

// Get shape of Cartesian subgrid
__cuhostdev__ intvec get_level_shape(const intvec & level_vector) {
    intvec grid_shape(level_vector.size());
    for (std::uint64_t i = 0; i < level_vector.size(); i++) {
        if (level_vector[i] == 0) {
            grid_shape[i] = 1;
        } else if (level_vector[i] == 1) {
            grid_shape[i] = 2;
        } else {
            grid_shape[i] = 1 << (level_vector[i]-1);
        }
    }
    return grid_shape;
}

// --------------------------------------------------------------------------------------------------------------------
// Canonical Decomposition
// --------------------------------------------------------------------------------------------------------------------

// Get flattened index from model index
__cuhostdev__ std::uint64_t model_to_contiguous_index(std::uint64_t i_dim, std::uint64_t i_pt, std::uint64_t i_rank,
                                                      std::uint64_t rank, const intvec & shape) {
    std::uint64_t result = 0;
    for (std::uint64_t i = 0; i < i_dim; i++) {
        result += shape[i];
    }
    return result + rank*i_pt + i_rank;
}

// Get model index from flattened index
__cuhostdev__ std::array<std::uint64_t, 3> contiguous_to_model_idx(std::uint64_t index, std::uint64_t rank,
                                                                   const intvec & shape) {
    std::uint64_t i_dim = 0, upper_bound = shape[0];
    while (index >= upper_bound) {
        i_dim += 1;
        upper_bound += shape[i_dim];
    }
    index -= upper_bound - shape[i_dim];
    return {i_dim, index / rank, index % rank};
}

}  // namespace merlin
