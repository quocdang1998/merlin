// Copyright 2022 quocdang1998
#include "merlin/utils.hpp"

#include <cinttypes>  // PRIu64
#include <cmath>      // std::floor, std::sqrt

#include "merlin/assume.hpp"  // assume

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Multi-dimensional Index
// ---------------------------------------------------------------------------------------------------------------------

// Product of all elements of the vector
__cuhostdev__ std::uint64_t prod_elements(const std::uint64_t * v, std::uint64_t size) {
    assume(size <= 16);
    std::uint64_t result = 1;
    for (std::uint64_t i = 0; i < size; i++) {
        result *= v[i];
    }
    return result;
}

// Inner product of 2 index vectors
__cuhostdev__ std::uint64_t inner_prod(const std::uint64_t * v1, const std::uint64_t * v2, std::uint64_t size) {
    assume(size <= 16);
    std::uint64_t inner_product = 0;
    for (std::uint64_t i = 0; i < size; i++) {
        inner_product += v1[i] * v2[i];
    }
    return inner_product;
}

// Convert n-dimensional index to C-contiguous index
__cuhostdev__ std::uint64_t ndim_to_contiguous_idx(const std::uint64_t * index, const std::uint64_t * shape,
                                                   std::uint64_t ndim) {
    assume(ndim <= 16);
    std::uint64_t c_index = 0, cum_prod = 1;
    for (std::int64_t i = ndim - 1; i >= 0; i--) {
        c_index += index[i] * cum_prod;
        cum_prod *= shape[i];
    }
    return c_index;
}

// Convert C-contiguous index to n-dimensional index and save data to a pre-allocated memory
__cuhostdev__ void contiguous_to_ndim_idx(std::uint64_t index, const std::uint64_t * shape, std::uint64_t ndim,
                                          std::uint64_t * data_ptr) {
    assume(ndim <= 16);
    // calculate index vector
    std::uint64_t cum_prod = 1;
    for (std::int64_t i = ndim - 1; i >= 0; i--) {
        data_ptr[i] = (index / cum_prod) % shape[i];
        cum_prod *= shape[i];
    }
}

// Increment of n-dim index
__cuhostdev__ std::int64_t increment_index(std::uint64_t * index, const std::uint64_t * shape, std::uint64_t ndim) {
    assume(ndim <= 16);
    // increasing index
    std::int64_t i_dim = ndim;
    bool keep_decresing, not_dim_break;
    do {
        i_dim--;
        keep_decresing = (index[i_dim] == shape[i_dim] - 1);
        index[i_dim] = (keep_decresing) ? 0 : index[i_dim] + 1;
        not_dim_break = (i_dim != 0);
    } while (keep_decresing && not_dim_break);
    return (keep_decresing) ? i_dim - 1 : i_dim;
}

// Increment of n-dim index
__cuhostdev__ std::int64_t decrement_index(std::uint64_t * index, const std::uint64_t * shape, std::uint64_t ndim) {
    assume(ndim <= 16);
    // decresing index
    std::int64_t i_dim = ndim;
    bool keep_decresing, not_dim_break;
    do {
        i_dim--;
        keep_decresing = (index[i_dim] == 0);
        index[i_dim] = (keep_decresing) ? shape[i_dim] - 1 : index[i_dim] - 1;
        not_dim_break = (i_dim != 0);
    } while (keep_decresing && not_dim_break);
    return (keep_decresing) ? i_dim - 1 : i_dim;
}

// ---------------------------------------------------------------------------------------------------------------------
// List Division
// ---------------------------------------------------------------------------------------------------------------------

// Get a list of pointers divided from an original array
__cuhostdev__ void ptr_to_subsequence(double * original, const std::uint64_t * divider_length, std::uint64_t num_seq,
                                      double ** data_ptr) {
    assume(num_seq <= 16);
    std::uint64_t jump = 0;
    for (std::uint64_t i = 0; i < num_seq; i++) {
        data_ptr[i] = original + jump;
        jump += divider_length[i];
    }
}

// Get index of sequence and index in that sequence of an index in original array
__cuhostdev__ std::array<std::uint64_t, 2> index_in_subsequence(std::uint64_t index_full_array,
                                                                const std::uint64_t * divider_length,
                                                                std::uint64_t num_seq) noexcept {
    assume(num_seq <= 16);
    std::uint64_t i_list = 0;
    std::int64_t index_in_list = index_full_array;
    for (std::uint64_t i = 0; i < num_seq; i++) {
        index_in_list -= divider_length[i];
        i_list += (index_in_list >= 0) ? 1 : 0;
        index_full_array = (index_in_list >= 0) ? index_in_list : index_full_array;
    }
    return {i_list, index_full_array};
}

// Get 2-dimensional triangular index from flatten index
__cuhostdev__ std::array<std::uint64_t, 2> triangular_index(std::uint64_t index) noexcept {
    std::array<std::uint64_t, 2> triangular_index;
    triangular_index[0] = std::floor((-1.f + std::sqrt(1.f + 8.f * index)) / 2.f);
    triangular_index[1] = index - (triangular_index[0] * (triangular_index[0] + 1)) / 2;
    return triangular_index;
}

}  // namespace merlin
