// Copyright 2022 quocdang1998
#include "merlin/splint/intpl/linear.hpp"

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Linear interpolation
// ---------------------------------------------------------------------------------------------------------------------

// Construct interpolation coefficients by linear interpolation method
__cuhostdev__ void splint::intpl::construct_linear(double * coeff, const double * grid_nodes,
                                                   const std::uint64_t & shape, const std::uint64_t & element_size,
                                                   const std::uint64_t & thread_idx,
                                                   const std::uint64_t & n_threads) noexcept {}

// Evaluate interpolation at an unit step by linear interpolation method
__cuhostdev__ void splint::intpl::evaluate_linear(const double * grid_nodes, const std::uint64_t & grid_shape,
                                                  const double & point, const std::uint64_t & coeff_index,
                                                  const double & coeff, double & result) noexcept {
    /*
    // calculate prod. of (point - x[i]) for i != i_node
    double evaluated_value = 1.0;
    for (std::uint64_t i_node = 0; i_node < grid_shape; i_node++) {
        evaluated_value *= (i_node != coeff_index) ? (point - grid_nodes[i_node]) : 1.0;
    }
    // multiply by coeff and add to result
    result += coeff * evaluated_value;
    */
    // evaluate (point - x[i]), (point - x[i-1]) and (point - x[i+1])
    /*
    double eval_i = point - grid_nodes[coeff_index];
    double eval_i_less = (coeff_index != 0) ? point - grid_nodes[coeff_index-1] : 0.0;

    if (eval > 0) {
        result += (point >= grid_nodes)
    }
    */
}

}  // namespace merlin
