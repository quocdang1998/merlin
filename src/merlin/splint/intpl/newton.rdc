// Copyright 2022 quocdang1998
#include "merlin/splint/intpl/newton.hpp"

#include <omp.h>  // #pragma omp, omp_get_num_threads

#include "merlin/logger.hpp"

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Newton interpolation
// ---------------------------------------------------------------------------------------------------------------------

// Construct interpolation coefficients by Newton method
__cuhostdev__ void splint::intpl::construction_newton(double * coeff, const double * grid_nodes,
                                                      const std::uint64_t & shape, const std::uint64_t & element_size,
                                                      const std::uint64_t & thread_idx,
                                                      const std::uint64_t & n_threads) noexcept {
    for (std::uint64_t jump = 1; jump < shape; jump++) {
        std::int64_t last_node = shape - 1 - jump;
        for (std::uint64_t i_node = 0; i_node <= last_node; i_node++) {
            // calculate 1 / (node[j] - node[j+i])
            double solvent = grid_nodes[i_node] - grid_nodes[i_node+jump];
            solvent = 1.f / solvent;
            // calculate divide difference: coeff[j] <- (coeff[j] - coeff[j+1]) /  (node[j] - node[j+i])
            for (std::uint64_t i_coeff = thread_idx; i_coeff < element_size; i_coeff += n_threads) {
                coeff[i_node*element_size + i_coeff] -= coeff[(i_node+1)*element_size + i_coeff];
                coeff[i_node*element_size + i_coeff] *= solvent;
            }
        }
    }
}

// Evaluate interpolation at an unit step by Newton method
__cuhostdev__ void splint::intpl::evaluate_newton(const double * grid_nodes, const std::uint64_t & grid_shape,
                                                  const double & point, const std::uint64_t & coeff_index,
                                                  const double & coeff, double & result) noexcept {
    result *= (coeff_index == 0) ? 1.0 : (point - grid_nodes[coeff_index]);
    result += coeff;
}

}  // namespace merlin
