// Copyright 2024 quocdang1998
#include "merlin/regpl/core.hpp"

#include <cmath>  // std::pow

#include "merlin/array/nddata.hpp"  // merlin::array::NdData
#include "merlin/grid/cartesian_grid.hpp"  // merlin::grid::CartesianGrid
#include "merlin/linalg/matrix.hpp"  // merlin::linalg::Matrix
#include "merlin/regpl/polynomial.hpp"  // merlin::regpl::Polynomial
#include "merlin/utils.hpp"  // merlin::contiguous_to_ndim_idx, merlin::triangular_index

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Calculate the vector to solve for regression system
// ---------------------------------------------------------------------------------------------------------------------

// Calculate the vector to solve for regression system with Cartesian grid
__cuhostdev__ void regpl::calc_vector(const grid::CartesianGrid & grid, const array::NdData & data,
                                      regpl::Polynomial & polynom, std::uint64_t * buffer, std::uint64_t thread_idx,
                                      std::uint64_t n_threads) noexcept {
    // assign buffer
    std::uint64_t ndim = grid.ndim();
    std::uint64_t * thread_buffer = buffer + thread_idx * ndim;
    // loop for each term
    for (std::uint64_t i_term = thread_idx; i_term < polynom.size(); i_term += n_threads) {
        // initialize coefficients
        double & coeff = polynom.coeff()[i_term];
        coeff = 0.0;
        // get order per dimension of the term
        contiguous_to_ndim_idx(i_term, polynom.order(), thread_buffer);
        // loop for each point in the grid
        for (std::uint64_t i_point = 0; i_point < grid.size(); i_point++) {
            // loop on each dimension
            std::uint64_t cum_prod_point = 1;
            double point_coeff = 1.0;
            std::uint64_t leap = 0;
            for (std::int64_t i_dim = ndim - 1; i_dim >= 0; i_dim--) {
                // calculate nd_index of point and term
                std::uint64_t nd_index_point = (i_point / cum_prod_point) % grid.shape()[i_dim];
                // get leap
                leap += nd_index_point * data.strides()[i_dim];
                // accumulate point evaluation into coefficient
                double point_coordinate = grid.grid_vectors()[i_dim][nd_index_point];
                for (std::uint64_t i_order = 0; i_order < polynom.order()[i_dim]; i_order++) {
                    point_coeff *= ((i_order < thread_buffer[i_dim]) ? point_coordinate : 1.0);
                }
                // update cum_prod
                cum_prod_point *= grid.shape()[i_dim];
            }
            // add point coeff back to vector
            std::uintptr_t data_ptr = reinterpret_cast<std::uintptr_t>(data.data()) + leap;
            coeff += *(reinterpret_cast<double *>(data_ptr)) * point_coeff;
        }
    }
}

// ---------------------------------------------------------------------------------------------------------------------
// Calculate the matrix to solve for regression system
// ---------------------------------------------------------------------------------------------------------------------

// Calculate the matrix to solve for regression system with Cartesian grid
__cuhostdev__ void regpl::calc_system(const grid::CartesianGrid & grid, const regpl::Polynomial & polynom,
                                      linalg::Matrix & matrix, std::uint64_t * buffer, std::uint64_t thread_idx,
                                      std::uint64_t n_threads) noexcept {
    // assign buffer
    std::uint64_t ndim = grid.ndim();
    std::uint64_t * row_buffer = buffer + 2 * thread_idx * ndim;
    std::uint64_t * col_buffer = row_buffer + ndim;
    // loop on each entries of the matrix
    std::uint64_t n_entries = (polynom.size() * (polynom.size() + 1)) / 2;
    for (std::uint64_t i_entry = thread_idx; i_entry < n_entries; i_entry += n_threads) {
        // get order per dimension
        auto [i_row, i_col] = triangular_index(i_entry);
        contiguous_to_ndim_idx(i_row, polynom.order(), row_buffer);
        contiguous_to_ndim_idx(i_col, polynom.order(), col_buffer);
        // loop on each point of the grid
        double scalar_product = 0.0;
        for (std::uint64_t i_point = 0; i_point < grid.size(); i_point++) {
            // calculate value of regression matrix at [i_point, i_row] and [i_point, i_column]
            std::uint64_t cum_prod_point = 1;
            double point_row = 1.0, point_col = 1.0;
            for (std::int64_t i_dim = grid.ndim() - 1; i_dim >= 0; i_dim--) {
                // calculate nd_index of point and term
                std::uint64_t nd_index_point = (i_point / cum_prod_point) % grid.shape()[i_dim];
                // accumulate point evaluation into coefficient
                double point_coordinate = grid.grid_vectors()[i_dim][nd_index_point];
                for (std::uint64_t i_order = 0; i_order < polynom.order()[i_dim]; i_order++) {
                    point_row *= ((i_order < row_buffer[i_dim]) ? point_coordinate : 1.0);
                    point_col *= ((i_order < col_buffer[i_dim]) ? point_coordinate : 1.0);
                }
                // update cum_prod
                cum_prod_point *= grid.shape()[i_dim];
            }
            // calculate inner product
            scalar_product += point_row * point_col;
        }
        // save result to matrix
        matrix.get(i_row, i_col) = scalar_product;
        matrix.get(i_col, i_row) = scalar_product;
    }
}

}  // namespace merlin
