// Copyright 2024 quocdang1998
#include "merlin/regpl/core.hpp"

#include "merlin/array/nddata.hpp"  // merlin::array::NdData
#include "merlin/grid/cartesian_grid.hpp"  // merlin::grid::CartesianGrid
#include "merlin/linalg/matrix.hpp"  // merlin::linalg::Matrix
#include "merlin/regpl/polynomial.hpp"  // merlin::regpl::Polynomial

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Calculate the vector to solve for regression system
// ---------------------------------------------------------------------------------------------------------------------

// Calculate the vector to solve for regression system with Cartesian grid
__cuhostdev__ void regpl::cacl_system(const grid::CartesianGrid & grid, const array::NdData & data,
                                      regpl::Polynomial & polynom, std::uint64_t thread_idx,
                                      std::uint64_t n_threads) noexcept {
    // loop for each term
    for (std::uint64_t i_term = thread_idx; i_term < polynom.size(); i_term += n_threads) {
        // initialize coefficients
        double & coeff = polynom.coeff()[i_term];
        coeff = 0.0;
        // loop for each point in the grid
        std::uint64_t ndim = grid.ndim();
        for (std::uint64_t i_point = 0; i_point < grid.size(); i_point++) {
            // loop on each dimension
            std::uint64_t cum_prod_point = 1, cum_prod_term = 1;
            double point_coeff = 1.0;
            std::uint64_t leap = 0;
            for (std::int64_t i_dim = ndim - 1; i_dim >= 0; i_dim--) {
                // calculate nd_index of point and term
                std::uint64_t nd_index_point = (i_point / cum_prod_point) % grid.shape()[i_dim];
                std::uint64_t nd_index_term = (i_term / cum_prod_term) % polynom.order()[i_dim];
                // get leap
                leap += nd_index_point * data.strides()[i_dim];
                // accumulate point evaluation into coefficient
                double point_coordinate = grid.grid_vectors()[i_dim][nd_index_point];
                for (std::uint64_t i_order = 0; i_order < nd_index_term; i_order++) {
                    point_coeff *= point_coordinate;
                }
                // update cum_prod
                cum_prod_point *= grid.shape()[i_dim];
                cum_prod_term *= polynom.order()[i_dim];
            }
            // add point coeff back to vector
            std::uintptr_t data_ptr = reinterpret_cast<std::uintptr_t>(data.data()) + leap;
            coeff += *(reinterpret_cast<double *>(data_ptr)) * point_coeff;
        }
    }
}

// ---------------------------------------------------------------------------------------------------------------------
// Calculate the matrix to solve for regression system
// ---------------------------------------------------------------------------------------------------------------------

// Calculate the matrix to solve for regression system with Cartesian grid
__cuhostdev__ void regpl::cacl_system(const grid::CartesianGrid & grid, const regpl::Polynomial & polynom,
                                      linalg::Matrix & matrix, std::uint64_t thread_idx,
                                      std::uint64_t n_threads) noexcept {
    // 
}

}  // namespace merlin
