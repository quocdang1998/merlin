// Copyright 2022 quocdang1998
#include "merlin/grid/cartesian_grid.hpp"

#include "merlin/utils.hpp"  // merlin::ptr_to_subsequence

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// CartesianGrid
// ---------------------------------------------------------------------------------------------------------------------

// Write coordinate of point to a pre-allocated memory
__cuhostdev__ void grid::CartesianGrid::get(std::uint64_t index, double * point_data) const noexcept {
    std::uint64_t cum_prod = 1;
    for (std::int64_t i = this->ndim() - 1; i >= 0; i--) {
        std::uint64_t nd_index = (index / cum_prod) % this->grid_shape_[i];
        point_data[i] = this->grid_vectors_[i][nd_index];
        cum_prod *= this->grid_shape_[i];
    }
}

// Write coordinate of point to a pre-allocated memory given index vector
__cuhostdev__ void grid::CartesianGrid::get(const Index & index, double * point_data) const noexcept {
    for (std::uint64_t i = 0; i < this->ndim(); i++) {
        point_data[i] = this->grid_vectors_[i][index[i]];
    }
}

#ifdef __NVCC__

// Copy to shared memory
__cudevice__ void * grid::CartesianGrid::copy_by_block(grid::CartesianGrid * dest_ptr, void * grid_data_ptr,
                                                       std::uint64_t thread_idx, std::uint64_t block_size) const {
    // shallow copy of grid node, size and ndim
    double * p_grid_nodes = reinterpret_cast<double *>(grid_data_ptr);
    std::uint64_t ndim = this->ndim();
    if (thread_idx == 0) {
        dest_ptr->grid_nodes_.assign(p_grid_nodes, this->num_nodes());
        dest_ptr->grid_shape_.resize(ndim);
        dest_ptr->size_ = this->size_;
        dest_ptr->grid_vectors_.resize(ndim);
    }
    __syncthreads();
    // copy data of grid nodes and grid shape
    std::uint64_t num_nodes = this->num_nodes();
    for (std::uint64_t i_node = thread_idx; i_node < num_nodes; i_node += block_size) {
        dest_ptr->grid_nodes_[i_node] = this->grid_nodes_[i_node];
    }
    __syncthreads();
    for (std::uint64_t i_dim = thread_idx; i_dim < ndim; i_dim += block_size) {
        dest_ptr->grid_shape_[i_dim] = this->grid_shape_[i_dim];
    }
    __syncthreads();
    // re-calculate grid vectors
    if (thread_idx == 0) {
        ptr_to_subsequence(p_grid_nodes, this->grid_shape_.data(), ndim, dest_ptr->grid_vectors_.data());
    }
    __syncthreads();
    return reinterpret_cast<void *>(p_grid_nodes + this->ndim());
}

// Copy to shared memory
__cudevice__ void * grid::CartesianGrid::copy_by_thread(grid::CartesianGrid * dest_ptr, void * grid_data_ptr) const {
    // shallow copy of grid node, size and ndim
    std::uint64_t ndim = this->ndim();
    double * p_grid_nodes = reinterpret_cast<double *>(grid_data_ptr);
    dest_ptr->grid_nodes_.assign(p_grid_nodes, this->num_nodes());
    dest_ptr->grid_shape_.resize(ndim);
    dest_ptr->size_ = this->size_;
    dest_ptr->grid_vectors_.resize(ndim);
    // copy data of grid nodes and grid shape
    std::uint64_t num_nodes = this->num_nodes();
    for (std::uint64_t i_node = 0; i_node < num_nodes; i_node++) {
        dest_ptr->grid_nodes_[i_node] = this->grid_nodes_[i_node];
    }
    for (std::uint64_t i_dim = 0; i_dim < ndim; i_dim++) {
        dest_ptr->grid_shape_[i_dim] = this->grid_shape_[i_dim];
    }
    // re-calculate grid vectors
    ptr_to_subsequence(p_grid_nodes, this->grid_shape_.data(), ndim, dest_ptr->grid_vectors_.data());
    return reinterpret_cast<void *>(p_grid_nodes + this->ndim());
}

#endif  // __NVCC__

}  // namespace merlin
