// Copyright 2023 quocdang1998
#include "merlin/candy/gradient.hpp"

#include <array>  // std::array

#include "merlin/array/nddata.hpp"  // merlin::array::NdData
#include "merlin/array/parcel.hpp"  // merlin::array::Parcel
#include "merlin/utils.hpp"         // merlin::index_in_subsequence, merlin::is_normal

namespace merlin {

// ---------------------------------------------------------------------------------------------------------------------
// Utils
// ---------------------------------------------------------------------------------------------------------------------

// Get ndim index with skipped dimension
__cuhostdev__ static void ndim_idx_wkd(std::uint64_t index, std::uint64_t skip_dim, const std::uint64_t * shape,
                                       std::uint64_t ndim, std::uint64_t * ndim_idx) noexcept {
    std::uint64_t cum_prod = 1;
    for (std::int64_t i = ndim - 1; i >= 0; i--) {
        bool skip = i == static_cast<std::int64_t>(skip_dim);
        ndim_idx[i] = (skip) ? (ndim_idx[i]) : ((index / cum_prod) % shape[i]);
        cum_prod *= (skip) ? 1.0 : shape[i];
    }
}

// ---------------------------------------------------------------------------------------------------------------------
// Calculate Gradient
// ---------------------------------------------------------------------------------------------------------------------

// Calculate gradient of a model based on relative square metric
__cuhostdev__ static double rlsquare_grad(const candy::Model & model, const array::NdData & train_data,
                                          std::uint64_t i_param, Index & index_mem) noexcept {
    // initialize gradient
    double gradient = 0.0;
    // get parameter index
    auto [param_dim, param_index, param_rank] = model.get_param_index(i_param);
    // loop over each point in the dataset to calculate the gradient
    std::uint64_t n_subset = train_data.size() / train_data.shape()[param_dim];
    index_mem[param_dim] = param_index;
    for (std::uint64_t i_point = 0; i_point < n_subset; i_point++) {
        // calculate ndim index
        ndim_idx_wkd(i_point, param_dim, train_data.shape().data(), train_data.ndim(), index_mem.data());
        // get point value
        std::uintptr_t point_ptr = reinterpret_cast<std::uintptr_t>(train_data.data());
        for (std::uint64_t i = 0; i < train_data.ndim(); i++) {
            point_ptr += index_mem[i] * train_data.strides()[i];
        }
        double point_value = *(reinterpret_cast<double *>(point_ptr));
        // check for normal data
        if (!is_normal(point_value)) {
            continue;
        }
        double point_gradient = 1.0;
        // divide by 1/point_value^2
        point_gradient /= point_value * point_value;
        // multiply by coefficient of the same rank from other dimension
        for (std::uint64_t i = 0; i < model.ndim(); i++) {
            point_gradient *= (i == param_dim) ? 1.0 : model.get(i, index_mem[i], param_rank);
        }
        // multiply by value evaluation
        double point_eval = model.eval(index_mem);
        point_gradient *= point_eval - point_value;
        // add gradient on a point to gradient of parameter
        gradient += point_gradient;
    }
    return gradient;
}

// Calculate gradient of a model based on relative square metric
__cuhostdev__ static double absquare_grad(const candy::Model & model, const array::NdData & train_data,
                                          std::uint64_t i_param, Index & index_mem) noexcept {
    // initialize gradient
    double gradient = 0.0;
    // get parameter index
    auto [param_dim, param_index, param_rank] = model.get_param_index(i_param);
    // loop over each point in the dataset to calculate the gradient
    std::uint64_t n_subset = train_data.size() / train_data.shape()[param_dim];
    index_mem[param_dim] = param_index;
    for (std::uint64_t i_point = 0; i_point < n_subset; i_point++) {
        // calculate ndim index
        ndim_idx_wkd(i_point, param_dim, train_data.shape().data(), train_data.ndim(), index_mem.data());
        // get point value
        std::uintptr_t point_ptr = reinterpret_cast<std::uintptr_t>(train_data.data());
        for (std::uint64_t i = 0; i < train_data.ndim(); i++) {
            point_ptr += index_mem[i] * train_data.strides()[i];
        }
        double point_value = *(reinterpret_cast<double *>(point_ptr));
        // check for normal data
        if (!is_finite(point_value)) {
            continue;
        }
        double point_gradient = 1.0;
        // multiply by coefficient of the same rank from other dimension
        for (std::uint64_t i = 0; i < model.ndim(); i++) {
            point_gradient *= (i == param_dim) ? 1.0 : model.get(i, index_mem[i], param_rank);
        }
        // multiply by value evaluation
        double point_eval = model.eval(index_mem);
        point_gradient *= point_eval - point_value;
        // add gradient on a point to gradient of parameter
        gradient += point_gradient;
    }
    return gradient;
}

// Function calculating gradient
__cuhostdev__ void candy::calc_gradient(const candy::Model & model, const array::NdData & train_data,
                                        DoubleVec & gradient, unsigned int metric, std::uint64_t thread_idx,
                                        std::uint64_t n_threads, Index & index_mem) noexcept {
    static std::array<candy::GradientCalc, 2> grad_methods = {rlsquare_grad, absquare_grad};
    for (std::uint64_t i_param = thread_idx; i_param < model.num_params(); i_param += n_threads) {
        gradient[i_param] = grad_methods[metric](model, train_data, i_param, index_mem);
    }
}

// ---------------------------------------------------------------------------------------------------------------------
// Gradient
// ---------------------------------------------------------------------------------------------------------------------

#ifdef __NVCC__

// Calculate gradient from data in GPU parallel section
__cudevice__ void candy::Gradient::calc_by_gpu(candy::Model & model, const array::Parcel & train_data,
                                               std::uint64_t thread_idx, std::uint64_t n_threads,
                                               Index & index_mem) noexcept {
    candy::calc_gradient(model, train_data, this->value_, static_cast<unsigned int>(this->train_metric_), thread_idx,
                         n_threads, index_mem);
    __syncthreads();
}

#endif  // __NVCC__

// Destructor
__cuhostdev__ candy::Gradient::~Gradient(void) {}

}  // namespace merlin
