// Copyright 2022 quocdang1998
#include "merlin/interpolant/sparse_grid.hpp"

#include <cstdint>  // std::uint64_t
#include <cinttypes>  // PRIu64

#include "merlin/logger.hpp"  // CUHDERR
#include "merlin/utils.hpp"  // merlin::contiguous_to_ndim_idx, merlin::get_level_from_valid_size
                             // merlin::hiearchical_index, merlin::get_level_shape, merlin::calc_subgrid_size

namespace merlin {

// --------------------------------------------------------------------------------------------------------------------
// SparseGrid
// --------------------------------------------------------------------------------------------------------------------

// Copy constructor
__cuhostdev__ interpolant::SparseGrid::SparseGrid(const interpolant::SparseGrid & src) :
grid_vectors_(src.grid_vectors_), level_index_(src.level_index_), sub_grid_start_index_(src.sub_grid_start_index_) {}

// Move constructor
__cuhostdev__ interpolant::SparseGrid::SparseGrid(interpolant::SparseGrid && src) :
grid_vectors_(src.grid_vectors_), level_index_(src.level_index_), sub_grid_start_index_(src.sub_grid_start_index_) {}

// Get shape of the grid
__cuhostdev__ intvec interpolant::SparseGrid::get_grid_shape(void) const noexcept {
    intvec grid_shape(this->ndim());
    for (std::uint64_t i_dim = 0; i_dim < grid_shape.size(); i_dim++) {
        grid_shape[i_dim] = this->grid_vectors_[i_dim].size();
    }
    return grid_shape;
}

// Max level per dimension
__cuhostdev__ intvec interpolant::SparseGrid::max_levels(void) const {
    intvec result(this->ndim(), 0);
    for (std::uint64_t i = 0; i < result.size(); i++) {
        result[i] = get_level_from_valid_size(this->grid_vectors_[i].size());
    }
    return result;
}

// Number of points in grid
__cuhostdev__ std::uint64_t interpolant::SparseGrid::size(void) const {
    std::uint64_t num_level = this->num_level();
    std::uint64_t result = 0;
    for (std::uint64_t i_level = 0; i_level < num_level; i_level++) {
        intvec dummy_level;
        dummy_level.assign(const_cast<std::uint64_t *>(&(this->level_index_[i_level*this->ndim()])), this->ndim());
        std::uint64_t subgrid_size = calc_subgrid_size(dummy_level);
        result += subgrid_size;
    }
    return result;
}

// Index of point in grid given its contiguous order
__cuhostdev__ intvec interpolant::SparseGrid::index_from_contiguous(std::uint64_t contiguous_index) const {
    // determine i_level
    std::uint64_t i_level;
    for (i_level = 0; i_level < this->ndim(); i_level++) {
        if (contiguous_index < this->sub_grid_start_index_[i_level+1]) {
            break;
        }
    }
    std::uint64_t contiguous_index_in_level = contiguous_index - this->sub_grid_start_index_[i_level];
    // calculate level shape
    intvec level_vector;
    level_vector.assign(const_cast<std::uint64_t *>(&(this->level_index_[i_level*this->ndim()])), this->ndim());
    intvec level_shape = get_level_shape(level_vector);
    // get index wrt full grid
    intvec ndim_index_in_level = contiguous_to_ndim_idx(contiguous_index_in_level, level_shape);
    intvec result(this->ndim());
    for (std::uint64_t i_dim = 0; i_dim < this->ndim(); i_dim++) {
        intvec full_grid_index = hiearchical_index(level_vector[i_dim], this->grid_vectors_[i_dim].size());
        result[i_dim] = full_grid_index[ndim_index_in_level[i_dim]];
    }
    return result;
}

// Point at a give multi-dimensional index.
__cuhostdev__ Vector<double> interpolant::SparseGrid::point_at_index(const intvec & index) const {
    if (index.size() != this->ndim()) {
        CUHDERR(std::invalid_argument, "Index must have the same ndim as the grid.\n");
    }
    Vector<double> result(this->ndim());
    for (std::uint64_t i_dim = 0; i_dim < this->ndim(); i_dim++) {
        result[i_dim] = this->grid_vectors_[i_dim][index[i_dim]];
    }
    return result;
}

}  // namespace merlin
