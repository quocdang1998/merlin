// Copyright 2022 quocdang1998
#include "merlin/interpolant/sparse_grid.hpp"

#include <cstdint>  // std::uint64_t
#include <cinttypes>  // PRIu64

#include "merlin/logger.hpp"  // CUHDERR

// --------------------------------------------------------------------------------------------------------------------
// Utils
// --------------------------------------------------------------------------------------------------------------------

namespace merlin {

// Get the level from a given valid size
__cuhostdev__ std::uint64_t get_level_from_size(std::uint64_t size) noexcept {
    size -= 1;
    std::uint64_t level = 0;
    while(size >>= 1) {
        ++level;
    }
    return level;
}

__cuhostdev__ intvec hiearchical_index(std::uint64_t level, std::uint64_t size) {
    // check level validity
    std::uint64_t max_level = get_level_from_size(size);
    if (level > max_level) {
        CUHDERR(std::invalid_argument, "Expected level less than %" PRIu64 ", got %" PRIu64 ".\n", max_level, level);
    }
    // trivial cases
    if (level == 0) {
        return intvec{(size - 1) / 2};
    } else if (level == 1) {
        return intvec{0, (size - 1)};
    }
    // normal cases: calculate the jump and loop over each odd number
    std::uint64_t jump = 1 << (max_level - level);
    intvec indices(1 << (level - 1));
    for (int i = 0; i < indices.size(); i++) {
        indices[i] = jump * (2*i + 1);
    }
    return indices;
}

// --------------------------------------------------------------------------------------------------------------------
// SparseGrid
// --------------------------------------------------------------------------------------------------------------------

// Max level per dimension
__cuhostdev__ intvec interpolant::SparseGrid::max_levels(void) {
    intvec result(this->ndim(), 0);
    for (int i = 0; i < result.size(); i++) {
        result[i] = get_level_from_size(this->grid_vectors_[i].size());
    }
    return result;
}

// Number of points in grid
__cuhostdev__ std::uint64_t interpolant::SparseGrid::size(void) {
    std::uint64_t num_subgrid = this->num_subgrid();
    std::uint64_t ndim = this->ndim();
    std::uint64_t result = 0;
    for (std::uint64_t i_subgrid = 0; i_subgrid < num_subgrid; i_subgrid++) {
        std::uint64_t subgrid_size = 1;
        std::uint64_t level_index = i_subgrid * ndim;
        for (std::uint64_t i_dim = 0; i_dim < ndim; i_dim++) {
            std::uint64_t & dim_level = this->level_vectors_[level_index + i_dim];
            if (dim_level == 0) {
                continue;
            }
            subgrid_size *= ((dim_level == 1) ? 2 : (1 << (dim_level-1)));
        }
        result += subgrid_size;
    }
    return result;
}

}  // namespace merlin
