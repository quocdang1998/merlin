// Copyright 2022 quocdang1998
#include "merlin/interpolant/sparse_grid.hpp"

#include <cstdint>  // std::uint64_t
#include <cinttypes>  // PRIu64

#include "merlin/logger.hpp"  // CUHDERR
#include "merlin/utils.hpp"  // merlin::contiguous_to_ndim_idx, merlin::get_level_from_valid_size
                             // merlin::hiearchical_index, merlin::get_level_shape

namespace merlin {

// --------------------------------------------------------------------------------------------------------------------
// SparseGrid
// --------------------------------------------------------------------------------------------------------------------

// Max level per dimension
__cuhostdev__ intvec interpolant::SparseGrid::max_levels(void) const {
    intvec result(this->ndim(), 0);
    for (int i = 0; i < result.size(); i++) {
        result[i] = get_level_from_valid_size(this->grid_vectors_[i].size());
    }
    return result;
}

// Number of points in grid
__cuhostdev__ std::uint64_t interpolant::SparseGrid::size(void) const {
    std::uint64_t num_subgrid = this->num_subgrid();
    std::uint64_t ndim = this->ndim();
    std::uint64_t result = 0;
    for (std::uint64_t i_subgrid = 0; i_subgrid < num_subgrid; i_subgrid++) {
        std::uint64_t subgrid_size = 1;
        std::uint64_t level_index = i_subgrid * ndim;
        for (std::uint64_t i_dim = 0; i_dim < ndim; i_dim++) {
            const std::uint64_t & dim_level = this->level_vectors_[level_index + i_dim];
            if (dim_level == 0) {
                continue;
            }
            subgrid_size *= ((dim_level == 1) ? 2 : (1 << (dim_level-1)));
        }
        result += subgrid_size;
    }
    return result;
}

// Index of point in grid given its contiguous order
__cuhostdev__ intvec interpolant::SparseGrid::index_from_contiguous(std::uint64_t contiguous_index) const {
    // determine i_level
    std::uint64_t i_level;
    for (i_level = 0; i_level < this->ndim(); i_level++) {
        if (contiguous_index < this->sub_grid_start_index_[i_level+1]) {
            break;
        }
    }
    std::uint64_t contiguous_index_in_level = contiguous_index - this->sub_grid_start_index_[i_level];
    // calculate level shape
    intvec level_vector;
    level_vector.data() = const_cast<std::uint64_t *>(&(this->level_vectors_[i_level * this->ndim()]));
    level_vector.size() = this->ndim();
    intvec level_shape = get_level_shape(level_vector);
    // get index wrt full grid
    intvec ndim_index_in_level = contiguous_to_ndim_idx(contiguous_index_in_level, level_shape);
    intvec result(this->ndim());
    for (std::uint64_t i_dim = 0; i_dim < this->ndim(); i_dim++) {
        intvec full_grid_index = hiearchical_index(level_vector[i_dim], this->grid_vectors_[i_dim].size());
        result[i_dim] = full_grid_index[ndim_index_in_level[i_dim]];
    }
    // for pointer of level_vector to nullptr to prevent double deallocation
    level_vector.data() = nullptr;
    return result;
}

}  // namespace merlin
