// Copyright 2022 quocdang1998
#ifndef MERLIN_ARRAY_HPP_
#define MERLIN_ARRAY_HPP_

#include <cstdint>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <vector>
#include <stdexcept>

namespace merlin {

/** @brief Multi-dimensional array.

    This class make the interface between C array and Numpy array.*/
template <typename Scalar>
class Array {
  public:
    /** @brief Multi-dimensional array iterator.*/
    class iterator {
      public:
        /** @brief Constructor from a vector of index and a dimension vector.*/
        iterator(const std::vector<unsigned int> & it,
                 std::vector<unsigned int> & dims) : it_(it), dims_(&dims) {}

        /** @brief Get index of current iterator.*/
        std::vector<unsigned int> & it(void) {return this->it_;}
        /** @brief Get index of constant iterator.*/
        const std::vector<unsigned int> & it(void) const {return this->it_;}
        /** @brief Get reference to the dimension vector of the iterator.*/
        std::vector<unsigned int> & dims(void) {return *(this->dims_);}

        /** @brief Update the indexes after increasing value of index.

            User can manually add a certain amount to the index vector, making
            some indexes greater than their corresponding dimensions. This
            function will detect the surplus quantity, and update the indices
            by carrying the surplus to higher stride dimensions.
            
            Example: Given a dimension vector \f$(5, 2)\f$, the index vector
            \f$(1, 5)\f$ will be updated to \f$(3, 1)\f$*/
        void update(void);

        /** @brief Pre-increment operator.

            Increase the index of the last dimension by 1. If the maximum is
            reached, set the index to zero and increment the next dimension.

            Example: \f$(0, 0) \rightarrow (0, 1) \rightarrow (0, 2)
            \rightarrow (1, 0) \rightarrow (1, 1) \rightarrow (1, 2)\f$.*/
        iterator& operator++(void);
        /** @brief Post-increment operator.
        
            Same role as pre-increment operator.*/
        iterator operator++(int);
        /** @brief Compare if the first iterator is smaller the second one.

            This operator is used to check if current iterator is the end
            iterator of Array.*/
        friend bool operator!= (const typename Array<Scalar>::iterator & left,
                                const typename Array<Scalar>::iterator & right) {
            // check if 2 iterators comes from the same array
            if (left.dims_ != right.dims_) {
                throw(std::runtime_error("2 iterators are not comming from the same array."));
            }
    
            // compare index of each iterator
            unsigned int length = left.it().size();
            for (int i = 0; i < length; i++) {
                if (left.it_[i] != right.it_[i]) {
                    return true;
                }
            }
            return false;
        }

      private:
        /** @brief Index vector.*/
        std::vector<unsigned int> it_;
        /** @brief Pointer to max diemension vector.*/
        std::vector<unsigned int> * dims_;
    };

    /** @brief Create array from NumPy array.*/
    Array(Scalar * data, unsigned int ndim,
          unsigned int * dims, unsigned int * strides,
          bool copy = true);
    /** @brief Destructor.*/
    ~Array(void);

    /** @brief Indicate array is copied or assigned to another array.

    If the array is copy version, delete operator is called when the array is
    destroyed to avoid memory leak.*/
    bool is_copy;
    /** @brief Size of the array.

    Product of the size of each dimension.*/
    unsigned int size();
    /** @brief Begin iterator.
    
    Vector of index \f$(0, 0, ..., 0)\f$.*/
    Array::iterator begin(void);
    /** @brief End iterator.

    Vector of index \f$(d_0, 0, ..., 0)\f$.*/
    Array::iterator end(void);
    /** @brief Sciling operator.

    Get an element at a given index.
    @param index Vector of indices along each dimension.*/
    Scalar & operator[] (const std::vector<unsigned int> & index);

  private:
    /** @brief Pointer to data.*/
    Scalar * data_;
    /** @brief Number of dimension.*/
    unsigned int ndim_;
    /** @brief Size of each dimension.*/
    std::vector<unsigned int> dims_;
    /** @brief Strides (address jump) when increasing index of a dimension
    by 1.*/
    std::vector<unsigned int> strides_;

    /** @brief Begin iterator.*/
    std::vector<unsigned int> begin_;
    /** @brief End iterator.*/
    std::vector<unsigned int>  end_;
};


// Constructor from pointer to data
template <typename Scalar>
Array<Scalar>::Array(Scalar * data, unsigned int ndim, unsigned int * dims,
             unsigned int * strides, bool copy) {
    // copy meta data
    this->ndim_ = ndim;
    this->dims_ = std::vector<unsigned int>(dims, dims + ndim);
    this->strides_ = std::vector<unsigned int>(strides, strides + ndim);
    this->is_copy = copy;

    // create begin and end iterator
    this->begin_ = std::vector<unsigned int>(this->ndim_, 0);
    this->end_ = std::vector<unsigned int>(this->ndim_, 0);
    this->end_[0] = this->dims_[0];

    // copy / assign data
    if (is_copy) {  // copy data
        // allocate a new array
        this->data_ = new Scalar [this->size()];

        // reform the stride array (force into C shape)
        this->strides_[ndim-1] = sizeof(Scalar);
        for (int i = ndim-2; i >= 0; i--) {
            this->strides_[i] = this->strides_[i+1] * this->dims_[i+1];
        }

        // longest contiguous array
        unsigned int longest_contiguous_segment = sizeof(Scalar);
        int break_index = ndim-1;
        for (int i = ndim-1; i >=0; i--) {
            if (this->strides_[i] == strides[i]) {
                longest_contiguous_segment *= dims[i];
                break_index--;
            } else {
                break;
            }
        }

        // copy data from old array to new array (optimized with memcpy)
        if (break_index == -1) {  // original array is perfectly contiguous
            std::memcpy(this->data_, data, longest_contiguous_segment);
        } else {  // memcpy each longest_contiguous_segment
            for (Array::iterator it = this->begin(); it != this->end();) {
                unsigned int leap = 0;
                for (int i = 0; i < it.it().size(); i++) {
                    leap += it.it()[i] * strides[i];
                }
                uintptr_t src_ptr = (uintptr_t) data + leap;
                uintptr_t des_ptr = (uintptr_t) &(this->operator[](it.it()));
                std::memcpy((Scalar *) des_ptr, (Scalar *) src_ptr,
                            longest_contiguous_segment);
                it.it()[break_index] += 1;
                try {
                    it.update();
                } catch (const std::out_of_range & err) {
                    break;
                }
            }
        }
    } else {
        this->data_ = data;
    }
}

// get item operator
template <typename Scalar>
Scalar & Array<Scalar>::operator[] (const std::vector<unsigned int> & index) {
    unsigned int leap = 0;
    if (index.size() != this->ndim_) {
        throw std::length_error("Index must have the same length as array");
    }
    for (int i = 0; i < index.size(); i++) {
        leap += index[i] * this->strides_[i];
    }
    uintptr_t data_ptr = (uintptr_t) this->data_ + leap;
    return *((Scalar *) data_ptr);
}

// pre-increment iterator
template <typename Scalar>
typename Array<Scalar>::iterator& Array<Scalar>::iterator::operator++(void) {
    this->it_[this->it_.size()-1]++;
    unsigned int current_dim = this->it_.size()-1;
    std::vector<unsigned int> & dims = this->dims();
    while (this->it_[current_dim] >= dims[current_dim]) {
        if (current_dim == 0) {
            if (this->it_[current_dim] == dims[current_dim]) {
                break;
            }
            else {
                throw(std::out_of_range("Maximum size reached, cannot add more."));
            }
        }
        this->it_[current_dim] = 0;
        this->it_[--current_dim] += 1;
    }
    return *this;
}

// post-increment operator
template <typename Scalar>
typename Array<Scalar>::iterator Array<Scalar>::iterator::operator++(int) {
    return ++(*this);
}

// destructor
template <typename Scalar>
Array<Scalar>::~Array(void) {
    if (this->is_copy) {
        std::printf("Free copied data.\n");
        delete[] this->data_;
    }
}

// get size
template <typename Scalar>
unsigned int Array<Scalar>::size() {
    unsigned int size = 1;
    for (int i = 0; i < this->ndim_; i++) {
        size *= this->dims_[i];
    }
    return size;
}

// begin iterator
template <typename Scalar>
typename Array<Scalar>::iterator Array<Scalar>::begin(void) {
    return Array<Scalar>::iterator(this->begin_, this->dims_);
}

// end iterator
template <typename Scalar>
typename Array<Scalar>::iterator Array<Scalar>::end(void) {
    return Array<Scalar>::iterator(this->end_, this->dims_);
}

template <typename Scalar>
void Array<Scalar>::iterator::update(void) {
    // detect dimensions having index bigger than dim
    unsigned int current_dim = this->it_.size();
    std::vector<unsigned int> & dims = this->dims();
    for (int i = this->it_.size() - 1; i >=0; i--) {
        if (this->it_[i] >= dims[i]) {
            current_dim = i;
            break;
        }
    }
    if (current_dim == this->it_.size()) {  // no update needed
        return;
    }

    // carry the surplus to the dimensions with bigger strides
    while (this->it_[current_dim] >= dims[current_dim]) {
        if (current_dim == 0) {
            if (this->it_[current_dim] == dims[current_dim]) {
                break;
            }
            else {
                throw(std::out_of_range("Maximum size reached, cannot add more."));
            }
        }
        div_t carry = div((int) this->it_[current_dim], (int) dims[current_dim]);
        this->it_[current_dim] = carry.rem;
        this->it_[--current_dim] += carry.quot;
    }
}

}  // namespace merlin

#endif  // MERLIN_ARRAY_HPP_
